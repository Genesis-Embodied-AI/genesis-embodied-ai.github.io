# _kernel_inverse_kinematics

import APITable from '@site/src/components/APITable';

:::info

This kernel function is used for solving inverse kinematics (IK) in a robotic system. It adjusts the joint configurations to achieve target end-effector positions and orientations. 

:::


:::danger Breaking changes in minor versions
Please be aware that there might be breaking changes in minor versions.
:::


## Overview {#overview}

The `_kernel_inverse_kinematics` API is designed to solve the inverse kinematics problem for a robotic manipulator with multiple links. It iteratively adjusts joint positions to minimize the positional and rotational errors between the current and target states of the end-effectors.

### Parameters

<APITable>
| Parameter | Type | Description |
|-----------|------|-------------|
| `links_idx` | ti.types.ndarray() | Indices of the links to be controlled. |
| `poss` | ti.types.ndarray() | Target positions for the end-effectors. |
| `quats` | ti.types.ndarray() | Target orientations for the end-effectors as quaternions. |
| `n_links` | ti.i32 | Number of links in the kinematic chain. |
| `custom_init_q` | ti.i32 | Flag to use custom initial joint positions. |
| `init_q` | ti.types.ndarray() | Custom initial joint positions. |
| `max_samples` | ti.i32 | Maximum number of samples for initial joint positions. |
| `max_solver_iters` | ti.i32 | Maximum number of iterations for the solver. |
| `damping` | ti.f32 | Damping factor for the solver. |
| `pos_tol` | ti.f32 | Position tolerance for the end-effectors. |
| `rot_tol` | ti.f32 | Rotation tolerance for the end-effectors. |
| `pos_mask_` | ti.types.ndarray() | Mask for position errors. |
| `rot_mask_` | ti.types.ndarray() | Mask for rotation errors. |
| `max_step_size` | ti.f32 | Maximum step size for joint position updates. |
| `respect_joint_limit` | ti.i32 | Flag to respect joint limits during updates. |
</APITable>

### Returns

This function does not return any value. It updates the joint positions to minimize the error between the current and target states of the end-effectors.

## Examples

```python
@ti.kernel
def example_inverse_kinematics():
    links_idx = ti.ndarray(...)
    poss = ti.ndarray(...)
    quats = ti.ndarray(...)
    n_links = 5
    custom_init_q = 1
    init_q = ti.ndarray(...)
    max_samples = 10
    max_solver_iters = 100
    damping = 0.01
    pos_tol = 1e-3
    rot_tol = 1e-3
    pos_mask_ = ti.ndarray(...)
    rot_mask_ = ti.ndarray(...)
    max_step_size = 0.1
    respect_joint_limit = 1
    
    _kernel_inverse_kinematics(
        links_idx, poss, quats, n_links, custom_init_q, init_q, max_samples,
        max_solver_iters, damping, pos_tol, rot_tol, pos_mask_, rot_mask_,
        max_step_size, respect_joint_limit
    )
```

The above example demonstrates how to use the `_kernel_inverse_kinematics` function to solve an inverse kinematics problem with given parameters.

