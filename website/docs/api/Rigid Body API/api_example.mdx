
# `_kernel_inverse_kinematics`

import APITable from '@site/src/components/APITable';

:::info

This method is part of the kinematics library and is used for inverse kinematics calculations. It utilizes Taichi (`ti.kernel`) to perform efficient computations. For more information on Taichi kernels, refer to [Taichi Documentation](https://taichi.graphics/docs/lang/articles/advanced/kernel).

:::

:::tip

The `_kernel_inverse_kinematics` function can be customized with various parameters to suit different kinematic configurations and constraints.

:::

:::danger Breaking changes in minor versions

Ensure compatibility with the latest version of the kinematics library, as minor updates may introduce breaking changes.

:::

:::note

This API is primarily used for calculating joint positions (`qpos`) to achieve desired end-effector positions (`poss`) and orientations (`quats`). It is essential for robotic motion planning and control.

:::

## Overview {#overview}

`_kernel_inverse_kinematics` performs inverse kinematics to compute joint angles for given target positions and orientations.

- Type: `Taichi kernel`

The `_kernel_inverse_kinematics` function supports:

- `positional and rotational constraints`
- `custom initial joint positions`
- `joint limits respect`

Examples:

```python title="_kernel_inverse_kinematics"
@ti.kernel
def _kernel_inverse_kinematics(
    links_idx: ti.types.ndarray(),
    poss: ti.types.ndarray(),
    quats: ti.types.ndarray(),
    n_links: ti.i32,
    custom_init_q: ti.i32,
    init_q: ti.types.ndarray(),
    max_samples: ti.i32,
    max_solver_iters: ti.i32,
    damping: ti.f32,
    pos_tol: ti.f32,
    rot_tol: ti.f32,
    pos_mask_: ti.types.ndarray(),
    rot_mask_: ti.types.ndarray(),
    max_step_size: ti.f32,
    respect_joint_limit: ti.i32,
):
    # Implementation details here
```

### Parameters

| Name                  | Type                     | Description                                                                 |
|-----------------------|--------------------------|-----------------------------------------------------------------------------|
| `links_idx`           | `ti.types.ndarray`       | Indices of the links for which inverse kinematics is being computed.       |
| `poss`                | `ti.types.ndarray`       | Target positions for the end-effectors.                                     |
| `quats`               | `ti.types.ndarray`       | Target orientations for the end-effectors in quaternion form.               |
| `n_links`             | `ti.i32`                 | Number of links/end-effectors.                                              |
| `custom_init_q`       | `ti.i32`                 | Flag to use custom initial joint positions.                                 |
| `init_q`              | `ti.types.ndarray`       | Custom initial joint positions.                                             |
| `max_samples`         | `ti.i32`                 | Maximum number of samples for the solver.                                   |
| `max_solver_iters`    | `ti.i32`                 | Maximum number of iterations for the solver per sample.                     |
| `damping`             | `ti.f32`                 | Damping factor for the solver.                                              |
| `pos_tol`             | `ti.f32`                 | Tolerance for position error.                                               |
| `rot_tol`             | `ti.f32`                 | Tolerance for rotation error.                                               |
| `pos_mask_`           | `ti.types.ndarray`       | Mask for position error calculation.                                        |
| `rot_mask_`           | `ti.types.ndarray`       | Mask for rotation error calculation.                                        |
| `max_step_size`       | `ti.f32`                 | Maximum step size for joint updates.                                        |
| `respect_joint_limit` | `ti.i32`                 | Flag to respect joint limits during the computation.                        |

### Usage

Here is an example of how to use `_kernel_inverse_kinematics` in your code:

```python
import taichi as ti

@ti.kernel
def example_ik(
    links_idx: ti.types.ndarray(),
    poss: ti.types.ndarray(),
    quats: ti.types.ndarray(),
    n_links: ti.i32,
    custom_init_q: ti.i32,
    init_q: ti.types.ndarray(),
    max_samples: ti.i32,
    max_solver_iters: ti.i32,
    damping: ti.f32,
    pos_tol: ti.f32,
    rot_tol: ti.f32,
    pos_mask_: ti.types.ndarray(),
    rot_mask_: ti.types.ndarray(),
    max_step_size: ti.f32,
    respect_joint_limit: ti.i32,
):
    _kernel_inverse_kinematics(
        links_idx, poss, quats, n_links, custom_init_q, init_q, max_samples, 
        max_solver_iters, damping, pos_tol, rot_tol, pos_mask_, rot_mask_, 
        max_step_size, respect_joint_limit
    )
```
